\chapter{Defining Mapbox Vector Tiles}\label{chapter_defining_mapbox_vector_tiles}

The main requirement regarding the content of the vector tiles is to be compatible with the vector tiles of Mapbox. This allows people to seamlessly switch to \osmvt{} and use the same visual styles created with Mapbox Studio. 

\section{Approach}
Mapbox's tileset is called Mapbox Streets. They provide detailed documentation on what data is included in the Mapbox Streets vector tiles. The documentation contains a layer reference which defines the attributes a layer can have. However the zoom levels at which data is shown is not documented publicly as well as the \osm{} tags and constraints describing the data. To be able to reverse engineer Mapbox Streets this information had to be retrieved by analyzing the official Mapbox Streets vector tiles at different zoom levels.\\
In an iterative and time consuming process the mapping and queries were continuously improved until the vector tile output matches the data from Mapbox Streets very closely.

\section{Implementation}
This section describes the main components which needed to be implemented in order to generate Mapbox Streets compatible vector tiles.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{images/osm_to_vectortiles_detailed}
\caption{Simplified process of data import to vector tile rendering}
\end{figure}

\clearpage

\subsection{Import Mapping}

Imposm3 is used to import the \osm{} data into the Postgres database. Imposm3 expects a definition of which \osm{} tags should be mapped to which database tables. This definition is called import mapping. It mainly satisfies the following two purposes:

\paragraph{Filter data} The mapping allows to declare which data needs to be imported. This is very important since only a subset of all \osm{} data is included in the vector tiles. Therefore not all \osm{} data needs to be imported.

\paragraph{Mapping data} The mapping allows to map \osm{} key/value pairs to a certain database table creating a structured and organized schema from unstructured data.\\

The example definition in listing \autoref{definition_of_mapping} maps \osm{} tags with the key \textbf{aeroway} and one of the values \textbf{runway}, \textbf{taxiway}, \textbf{apron} or \textbf{helipad} to the table \textbf{aero\_polygon}. The \textbf{aero\_polygon} table has the columns \textbf{id}, \textbf{geometry}, \textbf{timestamp} and \textbf{type}. During the import process Imposm3 transformes the \osm{} nodes, ways and relations to one of the geometry types point, linestring or polygon.

\begin{listing}[H]
\begin{yamlcode}
aero_polygon:
  type: polygon
  fields:
  - name: id
    type: id
  - name: geometry
    type: geometry
  - name: timestamp
    type: pbf_timestamp
  - name: type
    type: mapping_value
  mapping:
    aeroway:
    - runway
    - taxiway
    - apron
    - helipad
\end{yamlcode}
\caption{Definition of a single table in the import mapping}
\label{definition_of_mapping}
\end{listing}
\clearpage

\subsection{Zoom Level Views}\label{zoom_level_views}

Since only a subset of the data in the tables is shown on a given zoom level, SQL views for each zoom level were created. The figure \ref{definition_of_zoom_level_view} shows the definition of the SQL view for zoom level 9 of the aeroway layer. The zoom level view merges the data of both tables osm\_aero\_linestring and osm\_aero\_polygon and filters the data to only contain geometries of type runway.

\begin{listing}[H]
\begin{sqlcode}
CREATE OR REPLACE VIEW aeroway_z9 AS
    SELECT id AS osm_id, type, geometry
    FROM osm_aero_linestring
    WHERE type = 'runway'
    UNION ALL
    SELECT id AS osm_id, type, geometry
    FROM osm_aero_polygon
    WHERE type = 'runway';
\end{sqlcode}
\caption{Definition of zoom level view}
\label{definition_of_zoom_level_view}
\end{listing}

The zoom level views help to decouple the database tables which hold the actual data and the definition of the layer. This is very helpful for example if new data is added to a layer, as only the import mapping and the zoom level view needs to be modified.

\subsection{Layer Definition}

The source project contains the definition of the layers inside the vector tiles. The definition contains metadata to access the database and a query which returns the necessary data for this layer. The listing \autoref{definition_of_layer} shows the definition of the layer \textbf{aeroway}. The query does not directly access the database table \textbf{aero\_polygon} instead it queries the zoom level views \textbf{aeroway\_z9} and \textbf{aeroway\_z10to14}.

\begin{listing}[H]
\begin{yamlcode}
- id: aeroway
    Datasource: 
      dbname: osm
      host: db
      password: osm
      port: 5432
      table: |-
        (
          SELECT osm_ids2mbid(osm_id, is_polygon(geometry)) AS osm_id, geometry, type
          FROM (
            SELECT * FROM aeroway_z9
            WHERE z(!scale_denominator!) = 9
            UNION ALL
            SELECT * FROM aeroway_z10to14
            WHERE z(!scale_denominator!) BETWEEN 10 AND 14
          ) AS aeroway WHERE geometry && !bbox!
        ) AS data
      type: postgis
      user: osm
    properties: 
      "buffer-size": 4
\end{yamlcode}
\caption{Definition of layer aeroway}
\label{definition_of_layer}
\end{listing}

This layer definition serves as input to the vector tile renderer (Mapnik). The tile renderer will execute every layer query for each tile and replaces expressions like \textbf{!scale\_denominator!} (zoom level) and \textbf{!bbox!} (extent of the tile) with the values of the current tile. If the query above gets executed for a tile on zoom level 8 it won't return any data as the \textbf{WHERE} clause will return in both case false. Whereas if it gets executed on a tile on zoom level 9 all data of the zoom level view aeroway\_z9 will be included in the layer aeroway.

\subsection{Conclusion}

The \autoref{aero_db_schema} below shows how the database tables, zoom level views and layers are related to each other. This architecture helps to structure the \osm{} data inside the database and opens the possibility to optimize single zoom levels individually.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/aero_database_schema}
\caption{Relations between database tables, zoom level views and layer}
\label{aero_db_schema}
\end{figure}

\section{Problems and Optimizations}

During the development process of the map a number of problems were discovered and optimizations were implemented. This section explains the most interesting problems in detail.

\subsection{Avoid expensive Functions in Zoom Level Views}

The purpose of the zoom level views is to filter the data to only contain rows that are shown on a specific zoom level. Expensive calculations or transformations should be avoided in these views.\\
For example there are multiple label layers which transform a polygon geometry to a point geometry. Doing transformations like these in the zoom level views results in bad rendering performance. 
The reason for this is that every time the layer query gets executed all rows of the view are transformed and only then most of the rows were discarded because they didn't fit in the bounding box. So first selecting the right row and only executing the transformation on this subset resulted obviously in way better performance.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{images/expensive_functions}
\caption{Example of expensive function which was moved into the layer query}
\end{figure}

\begin{tcolorbox}[arc=0mm,boxrule=1pt,title=Learning]
Expensive transformations should either be  made in a preprocessing step or if that's not possible the dataset should be reduced to the smallest size possible.
\end{tcolorbox}
\clearpage

\subsection{Helper functions}

Small helper functions were created to make the queries more readable and secondly to reuse common logic through multiple queries.\\ 
Mapbox has introduced a complex classification schema to be able to filter features of a single layer. For example the layer landuse contains features of class park, school, cemetery and many more. This allows people to style these areas differently. OpenStreetMap has an entirely different data model. Therefore a helper function was created to assign the right class value to each row.

\begin{listing}[H]
\begin{sqlcode}
CREATE OR REPLACE FUNCTION landuse_class(type VARCHAR) RETURNS VARCHAR
AS $$
BEGIN
    RETURN CASE
        WHEN type IN ('park', 'dog_park', 'garden', 'playground') THEN 'park'
        WHEN type IN ('school', 'college', 'university') THEN 'school'
        WHEN type IN ('cemetery', 'christian', 'jewish') THEN 'cemetery'
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
\end{sqlcode}
\caption{Definition of classification helper function}
\label{definition_of_classification_helper_function}
\end{listing}

The listing \autoref{definition_of_classification_helper_function} shows the simplified class function of the layer landuse it takes the type value as input and returns the correct class value. 

\paragraph{Expensive helper functions} In many cases these helper functions are used inside the zoom level views. For example from zoom level 5 to 6 only rows of class wood are shown. It turned out that this function introduced a bottleneck. The function could not be moved to the layer query like the example with the ST\_PointOnSurface transformation above, because it is used to filter the data. So an index on the stored procedure was created which improved the performance.

\begin{listing}[H]
\begin{sqlcode}
CREATE OR REPLACE VIEW landuse_z5toz6 AS
    SELECT id AS osm_id, geometry, type
    FROM osm_landuse_polygon_gen0
    WHERE landuse_class(type) = 'wood';
\end{sqlcode}
\caption{Definition of landuse zoom level view}
\label{definition_of_landuse_zoom_level_view}
\end{listing}
\clearpage

\subsection{OpenStreetMap ID Transformation}

The data model of \osm{} consists of nodes, ways and relations. Every object gets its own OSM ID assigned. This OSM ID is not unique across object types. Therefore one can find three objects with the same OSM ID but with a different object type.\\
While this works perfectly fine for \osm{}, this represents a problem because during the import process as the \osm{} objects get transformed to PostGIS geometries. For example an object of type way and relation could get transformed to a linestring geometry.

In order to ensure that the \osm{} ID remains the IDs need to be transformed according to \autoref{osm_id_transformation} into the same ID space Mapbox is using to make OSM IDs unique within vector tiles \cite{103_mapbox.com_2016}.

\begin{table}[H]
\centering

\begin{tabular}{lll}
\hline
OSM type & Geometry type                  & \osm{} ID transform \\ \hline
node     & point                          & id x 10          \\
way      & linestring                           & (id x 10) + 1    \\
way      & polygon + polygon label points & (id x 10) + 2    \\
relation & linestring                           & (id x 10) + 3    \\
relation & polygon + polygon label points & (id x 10) + 4    \\
\end{tabular}
\caption{OSM id transformation}
\label{osm_id_transformation}
\end{table}

\subsubsection*{Algorithm}
Input: OpenStreetMap osm\_id\\
Output: Mapbox osm\_id
\begin{enumerate}
    \item If osm\_id is point geometry return osm\_id * 10
    \item If osm\_id has object type way and was transformed to linestring\\
    return (osm\_id * 10) + 1
    \item If osm\_id has object type way and was transformed to polygon\\
    return (osm\_id * 10) + 2
    \item If  osm\_id has object type relation and was transformed to linestring\\
    return (osm\_id * 10) + 3
    \item If osm\_id has object type relation and was transformed to polygon\\
    return (osm\_id * 10) + 4
\end{enumerate}

\clearpage
\subsection{Place Label Rank Calculation}\label{place_label_rank_calc}

Ranks are important for determining at which zoom level which places should be displayed. The NaturalEarth database contains places with scaleranks assigned by humans and is the most important source for better quality labels (historic places might be much more important despite having a very small population). This dataset is merged with the imported \osm{} data.
They can also be used to limit density at lower zoom levels to decrease data density.

\subsubsection*{Algorithm}

\begin{enumerate}  
    \item Divide map into grid
    \item Group labels by tile index
    \item Sort labels by scalerank, type and population within group
    \begin{enumerate}
        \item By scalerank ascending
        \item By type city, town, village, hamlet, suburb, neighbourhood
        \item By population descending
    \end{enumerate}
    \item Assign row number as \texttt{localrank}
\end{enumerate}


\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/rank_calculation.png}
\caption{Local place rank calculation}
\end{figure}

